AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, Seed=927)
#' Combine Acoustic and Midwater Trawl Survey Data
#'
#' Combine survey data from acoustic transects and midwater trawl tows (created by \code{\link{SampFish}}).  
#' Apply availability to the acoustic data and catchability (availability and selectivity) to the midwater trawl catch.
#'
#' @param SimPop A list with elements \code{LakeInfo}, \code{FishInfo}, \code{FishParam}, \code{FishPop}, typically output from \code{\link{SimFish}}.
#' See \code{\link{SimFish}} for details on the list elements.
#' @param AcMtSurv A list with elements \code{Targets}, \code{AcSummaryCell}, \code{AcSummaryColumn}, \code{MtCatch}, 
#' typically output from \code{\link{SampFish}}.
#' @param SelecParamA data frame with 6 columns in which each row provides the midwater trawl selectivity parameters for
#' a given fish group and mesh panel zone.
#' All columns must be completely filled in (no missing values).
#' Selectivity is assumed to be 100\% for any group-zone combination not represented as a row in the data frame.
#' For 100\% selectivity of small fish, use \code{MtL50Small = -Inf} and any slope.  
#' For 100\% selectivity of large fish, use \code{MtL50Large = Inf} and any slope. 
#' Column names and descriptions:
#' \itemize{
#'   \item \code{G} = character, a one-letter nickname for the group (e.g., fish species and lifestage) used in plotting
#'   \item \code{Zone} = character, mesh panel zone, one of "mouth", "middle", "aft", or "cod"
#'   \item \code{MtL50Small} = numeric, the length (in mm) at which small fish have a 50\% probability of being captured by the trawl
#'   \item \code{MtSlopeSmall} = numeric, the (inverse) slope at which small fish probability of capture increases with length, smaller values are steeper
#'   \item \code{MtL50Large} = numeric, the length (in mm) at which large fish have a 50\% probability of being captured by the trawl
#'   \item \code{MtSlopeLarge} = numeric, the (absolute value of the inverse) slope at which large fish probability of capture decreases with length, smaller values are steeper
#' }
#' @param PanelProps A numeric vector of length 4, size of the different mesh panel zones of the midwater trawl, 
#' mouth (outermost), middle, aft, and cod (inner), default c(0.4, 0.3, 0.2, 0.1).
#' Sizes are expressed as proportions of the distance from the outer edge of the trawl to the trawl center in both the vertical and horizontal directions,
#' and they should add up to 1.  Use \code{\link{ViewZones}} to visualize the mesh panel zones.
#' @param AcExclA numeric vector of length 2, depth of acoustic "dead" zones at the surface and at the bottom (in m), 
#' default of c(0, 0) represents 100\% acoustic availability of fish.
#' @param MtExclA numeric vector of length 2, depth of zones unfishable with the midwater trawl at the surface and at the bottom (in m), 
#' default of c(0, 0) represents 100\% midwater trawl availability of fish.
#' @param SeedAn integer scalar, starting seed for stochasticity incorporated in acoustic and midwater trawl catchability.  
#' Use \code{Seed} to ensure the same individual fish are included in the surveys with each call to \code{CatchComb}.  
#' Otherwise, if set to NULL, the default, a random seed is used, resulting in a different fish selection with each call to \code{CatchComb}.  
#'
#' @returnA data frame with estimated fish density (in number per ha) and biomass (in kg per ha) for each sampling event and group (species, lifestage).
#'
#' @details
#'
#' A classification tree is used to relate the catch composition of the midwater trawl to the location of the trawl in the lake 
#' (e.g., MTReast, ACnorth, MTRd2sh, MTRbdep).  This tree is then used to assign a single midwater trawl catch to each acoustic cell
#' (interval x layer), such that the estimated acoustic densities can be assigned to specific fish groups (species, life stages).  See,
#' for example, Yule et al. (2013).
#'
#' @export
#' @importrpart
#' @seealso \code{\link{SimFish}}, \code{\link{SampFish}}, \code{\link{ViewZones}}, \code{\link{TuneSelec}}.
#' @references 
#' 
#' Yule, DL, JV Adams, DM Warner, TR Hrabik, PM Kocovsky, BC Weidel, LG Rudstam, and PJ Sullivan.  2013.  
#' \href{http://www.nrcresearchpress.com/doi/abs/10.1139/cjfas-2013-0072#.U1KYxPldXTQ}{Evaluating 
#' analytical approaches for estimating pelagic fish biomass using simulated fish communities}. 
#' Canadian Journal of Fisheries and Aquatic Sciences 70:1845-1857.
#' 
#' @examples
#'
#' # parameters for small (a) and large (A) alewife as input to the simulator
#' fishp <- data.frame(
#' G = c("a", "A", "A"), 
#' Z = c(50, 140, 140), ZE = c(0.25, 0.2, 0.2), 
#' LWC1 = 0.000014, LWC2 = 2.8638, LWCE = 0.18, 
#' TSC1 = -64.2, TSC2 = 20.5, TSCE = c(0.02, 0.07, 0.07), 
#' PropN = c(0.55, 0.25, 0.20), 
#' E = c(NA, 900, 2800), EE = c(NA, 4.5, 0.3), 
#' N = NA, NE = NA, 
#' WD = c(5, 15, 15), WDE = c(0.5, 0.7, 0.7), 
#' D2B = NA, D2BE = NA)
#' 
#' # simulate the fish population
#' res <- SimFish(LakeName="Clear Lake", LkWidth=3000, LkLength=2000, BotDepMin=20, BotDepMax=100, 
#' FishParam=fishp, TotNFish=50000)
#'
#' # survey the population
#' surv <- SampFish(SimPop=res, NumEvents=2, AcNum=5, AcInterval=3000, AcLayer=10, AcAngle=7, MtNum=25, MtHt=10, MtWd=10, MtLen=200)
#'
#' selec <- data.frame(
#' G = c("A", "a", "A", "a", "A", "a"), 
#' Zone = c("mouth", "mouth", "middle", "middle", "aft", "aft"), 
#' MtL50Small = c(100, 100, 60, 60, 30, 30), 
#' MtSlopeSmall = c(40, 40, 30, 30, 20, 20), 
#' MtL50Large = c(180, 180, Inf, Inf, Inf, Inf), 
#' MtSlopeLarge = c(20, 20, 100, 100, 100, 100))
#'
#' AcMtEst(SimPop=res, AcMtSurv=surv, Seed=927)
#' AcMtEst(SimPop=res, AcMtSurv=surv, SelecParam=selec, AcExcl=c(5, 10), MtExcl=c(2, 2), Seed=204)
#'
AcMtEst <- function(SimPop, AcMtSurv, PanelProps=c(0.4, 0.3, 0.2, 0.1), SelecParam=NULL, AcExcl=c(0, 0), MtExcl=c(0, 0), Seed=NULL) {
# SimPop=res
# AcMtSurv=surv
# SelecParam=selec
# PanelProps=c(0.4, 0.3, 0.2, 0.1)
# AcExcl=c(5, 10)
# MtExcl=c(0, 0)
# Seed=245
if(!is.null(Seed)) set.seed(Seed)
mtr <- AcMtSurv$MtCatch
srv <- AcMtSurv$SurvParam
ac <- AcMtSurv$Targets
# check validity of the trawl zone proportions that were input
names(PanelProps) <- c("mouth", "middle", "aft", "cod")
panelprops <- rev(PanelProps)
if(round(sum(panelprops), 0.0000001) != 1) stop("cod proportions should sum to 1")
# availability function, = 0 at surface and bottom and = 1 in the middle
dblcut <- function(wdep, surfacecut, d2bot, bottomcut) {
as.numeric(wdep > surfacecut & d2bot > bottomcut)
}
# acoustic availability
ac$keep <- with(ac, dblcut(wdep=f.wdep, surfacecut=AcExcl[1], d2bot=f.d2bot, bottomcut=AcExcl[2]))
# summarize by cell (interval x layer)
acs <- AcSmry(AcTarg=ac[ac$keep==1, ], LakeInfo=SimPop$LakeInfo, SurvParam=AcMtSurv$SurvParam)$AcCell
# midwater trawl availability
if(is.null(SelecParam)) {
SelecParam <- data.frame(
G = character(),
Zone = character(),
MtL50Small = numeric(0),
MtSlopeSmall = numeric(0),
MtL50Large = numeric(0),
MtSlopeLarge = numeric(0))
}
# check validity of zones
suz <- c("mouth", "middle", "aft", "cod")
uz <- unique(SelecParam$Zone)
badzones <- setdiff(uz, suz)
if(length(badzones) > 0) stop('Zones must be one of "mouth", "middle", "aft", or "cod".')
# check for missings
missings <- sum(is.na(SelecParam))
if(missings > 0) stop("SelectParam data frame may not have any missing values.")
# fill in 100% selectivities for group-zones with no parameters
sug <- sort(unique(AcMtSurv$MtCatch$G))
full <- expand.grid(G=sug, Zone=suz)
selec2 <- merge(SelecParam, full, all=TRUE)
sel100 <- is.na(selec2$MtL50Small)
selec2$MtL50Small[sel100] <- -Inf
selec2$MtSlopeSmall[sel100] <- 100
selec2$MtL50Large[sel100] <- Inf
selec2$MtSlopeLarge[sel100] <- 200
# for each fish, determine its maximum vertical or horizontal distance from the center of the trawl
# as a proportion of the trawl dimensions
mtr$maxdist <- with(mtr, pmax(abs(f.wdep - MTRwdep)/srv["MtHt"], abs(f.north - ACnorth)/srv["MtWd"]))
# use this distance to assign each fish to a zone of the trawl
mtr$Zone <- cut(mtr$maxdist, breaks=c(0, cumsum(panelprops)), include.lowest=TRUE, labels=names(panelprops))
mtrsel <- merge(mtr, selec2, all.x=TRUE)
# Think about trawl availability ... when we are cutting off trawls near the surface or the bottom, shouldn't this constraint happen
# during the survey itself, where trawls that encompass those "dead" zones can be eliminated?
mtrsel$p.avail <- with(mtrsel, dblcut(wdep=f.wdep, surfacecut=MtExcl[1], d2bot=f.d2bot, bottomcut=MtExcl[2]))
mtrsel$p.selec <- with(mtrsel, logit2(x=len, x50a=MtL50Small, slopea=MtSlopeSmall, x50b=MtL50Large, slopeb=-MtSlopeLarge))
mtrsel$p.catch <- mtrsel$p.avail*mtrsel$p.selec
# apply catchability (selectivity AND availability) functions to "perfect" MTR catch
mtrsel$keep <- sapply(mtrsel$p.catch, function(p) sample(0:1, size=1, replace=TRUE, prob=c(1-p, p)))
sue <- sort(unique(acs$Event))
results <- expand.grid(G=sug, Event=sue, nperha=NA, kgperha=NA)
for(k in sue) {
# subset the MT data
mtk <- mtrsel[mtrsel$Event==k & mtrsel$keep==1, ]
# only do these calculations if there were "keep" fish in the midwater trawl
# without "keep" fish, no species-specific density and biomass can be estimated
if(dim(mtk)[1] > 0) {
# subset the AC data
ack <- acs[acs$Event==k, ]
# make the variable names in mtk the same as in those in ack for tree prediction
names(mtk)[match(c("MTReast", "MTRd2sh", "MTRbdep", "MTRwdep", "MTRd2bot"), names(mtk))] <- c("interval", "d2sh", "botdep", "layer", "d2bot")
# fit a classification tree to the MTR data for Event k
treek <- rpart(as.factor(G) ~ interval + ACnorth + d2sh + botdep + layer + d2bot, data=mtk, control=list(cp=0.05, minsplit=10, minbucket=5))
# mean density for each species
# suffixes:  e = event, a = ac transect, i = interval, l = layer
# use the fitted tree to predict species composition of each AC interval/layer
pred.props <- predict(treek, newdata=ack)
dens.eail <- ack$nperha*pred.props
dens.eai <- aggregate(dens.eail, ack[, c("ACid", "interval")], sum)
dens.e <- apply(dens.eai[, sug], 2, mean)
# mean biomass for each species
# calculate the mean weight of each group at each node of the fitted tree
mwt <- tapply(mtk$wt, list(treek$where, mtk$G), mean)
mwt[is.na(mwt)] <- 0
# proportions corresponding to each node
pred.node <- prednode(treek, newdata=ack)
# mean weigth expanded to full dimensions of ack, by matching node number
mwt.eail <- mwt[match(pred.node, row.names(mwt)), ]
bio.eail <- mwt.eail * dens.eail
bio.eai <- aggregate(bio.eail, ack[, c("ACid", "interval")], sum)
bio.e <- apply(bio.eai[, sug], 2, mean)
for(g in seq(sug)) {
sel <- results$Event==k & results$G==sug[g]
results$nperha[sel] <- dens.e[sug[g]]
results$kgperha[sel] <- bio.e[sug[g]]/1000
}
}
}
results$nperha[is.na(results$nperha)] <- 0
results$kgperha[is.na(results$kgperha)] <- 0
results[, c("Event", "G", "nperha", "kgperha")]
}
# perfect
AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, Seed=927)
#' Summarize Acoustic Survey Data
#'
#' Summarize acoustic survey data by interval and layer.
#'
#' @param AcTarg A data frame list with information on fish detected in an acoustics survey, specifically the \code{Targets} data frame
#' output from \code{\link{SampFish}}.  Each row represents a single target, columns describe the specific location of fish in the lake and their target strengths.  
#' @param LakeInfoA list with the lake inputs supplied as arguments to \code{\link{SimFish}} as well as a few additional objects.
#' @param SurvParamA named vector with the survey inputs supplied as arguments to \code{\link{SampFish}}.
#'
#' @return A list with 2 elements.  
#' \itemize{
#'   \item \code{AcCell} is a data frame with information on the acoustic survey summarized by acoustic interval and layer.
#'   \item \code{AcColumn} is a data frame with information on the acoustic survey summarized by acoustic interval.
#' }
#'
#' @details
#'
#' Acoustic intervals are identified by the easting (in m) of their midpoint.
#' Acoustic layers are indentified by the water depth (in m) of their midpoint.
#'
#' A weighting variable, range weight (Yule 2000), is used to account for different volumes of water
#' sampled in the acoustic survey as a function of the distance from the transducer (in m) and the transducer half angle (0.5 * \code{AcAngle}).
#' The sum of the range weights is reported as \code{sum.rw} in the \code{AcCell} and \code{AcColumn} data frames.
#'
#' @export
#' @import MASS
#' @seealso \code{\link{SampFish}}
#' @references 
#' 
#' Yule, DL.  2000.  
#' \href{http://www.tandfonline.com/doi/abs/10.1577/1548-8675(2000)020%3C0759%3ACOHAAP%3E2.3.CO%3B2}{Comparison 
#' of horizontal acoustic and purse-seine estimates of salmonid densities and sizes in eleven Wyoming waters}. 
#' North American Journal of Fisheries Management 20:759-775.
#'
#' @examples
#'
#' # parameters for small (a) and large (A) alewife as input to the simulator
#' fishp <- data.frame(
#' G = c("a", "A", "A"), 
#' Z = c(50, 140, 140), ZE = c(0.25, 0.2, 0.2), 
#' LWC1 = 0.000014, LWC2 = 2.8638, LWCE = 0.18, 
#' TSC1 = -64.2, TSC2 = 20.5, TSCE = c(0.02, 0.07, 0.07), 
#' PropN = c(0.55, 0.25, 0.20), 
#' E = c(NA, 900, 2800), EE = c(NA, 4.5, 0.3), 
#' N = NA, NE = NA, 
#' WD = c(5, 15, 15), WDE = c(0.5, 0.7, 0.7), 
#' D2B = NA, D2BE = NA)
#' 
#' # simulate the fish population
#' res <- SimFish(LakeName="Clear Lake", LkWidth=3000, LkLength=2000, BotDepMin=20, BotDepMax=100, 
#' FishParam=fishp, TotNFish=50000, Seed=667)
#'
#' # survey the population
#' surv <- SampFish(SimPop=res, NumEvents=2, AcNum=5, AcInterval=3000, AcLayer=10, AcAngle=7, MtNum=25, MtHt=10, MtWd=10, MtLen=200, Seed=545)
#'
#' AcSmry(AcTarg=surv$Targets, LakeInfo=res$LakeInfo, SurvParam=surv$SurvParam)
#'
AcSmry <- function(AcTarg, LakeInfo, SurvParam) {
# AcTarg=surv$Targets
# LakeInfo=res$LakeInfo
# SurvParam=surv$SurvParam
# add "range weight" to the AcTarg data (Yule 2000)
# a weighting variable to account for different volumes sampled as a function of range (dist. from ducer in m) and ducer half angle
AcTarg$rng.wt <- 1/(2*AcTarg$f.wdep*tan(SurvParam["AcAngle"]))
# summarize acoustic data by interval and layer
AC2 <- aggregate(AcTarg[, "rng.wt"], AcTarg[, c("Event", "ACid", "ACnorth", "interval", "layer")], sum)
names(AC2)[names(AC2)=="x"] <- "sum.rw"
AC2$nperha <- 10000 * AC2$sum.rw/SurvParam["AcInterval"]
# create a matrix of all possible interval-by-layer combinations for each ACid
# this will be used to ensure that interval-by-layers with no fish are included in the summaries
eastr <- c(0, LakeInfo$LkWidth)
intbrks <- seq(eastr[1], eastr[2] + SurvParam["AcInterval"] - 1, SurvParam["AcInterval"])
intmids <- intbrks[-1] - SurvParam["AcInterval"]/2
laybrks <- seq(0, LakeInfo$BotDepMax + SurvParam["AcLayer"] - 1, SurvParam["AcLayer"])
laymids <- laybrks[-1] - SurvParam["AcLayer"]/2
# each AC transect goes over the same depth profile, so we can determine the max depth for each interval
# then see whether the max layer included
easts <- seq(eastr[1], eastr[2], length=1000)
depth.contour <- zfromx(x=easts, maxz=LakeInfo$BotDepMax, eastr=eastr, ints=LakeInfo$ints, slopes=LakeInfo$slopes)
depth.cont.int <- intmids[cut(easts, include.lowest=TRUE, breaks=intbrks, labels=FALSE)]
all.maxes <- tapply(depth.contour, depth.cont.int, max)
max.lays <- laymids[cut(all.maxes, include.lowest=TRUE, breaks=laybrks, labels=FALSE)]
# full matrix of all ACids, all intervals, and all layers
sua <- sort(unique(AcTarg$ACid))
full.mat <- expand.grid(layer=seq(laymids[1], max(max.lays), SurvParam["AcLayer"]), interval=intmids, ACid=1:(SurvParam["NumEvents"]*SurvParam["AcNum"]))
full.mat$Event <- recode(full.mat$ACid, sua, AcTarg$Event[match(sua, AcTarg$ACid)])
sub.mat <- merge(data.frame(interval=intmids, max.layer=max.lays), full.mat, all=TRUE)
sub.mat <- sub.mat[sub.mat$layer <= (sub.mat$max.layer + 0.001), c("Event", "ACid", "interval", "layer")]
ACsmryIL <- merge(AC2, sub.mat, all=TRUE)
ACsmryIL$nperha[is.na(ACsmryIL$nperha)] <- 0
ACsmryIL$sum.rw[is.na(ACsmryIL$sum.rw)] <- 0
ACsmryIL$ACnorth <- recode(ACsmryIL$ACid, sua, AcTarg$ACnorth[match(sua, AcTarg$ACid)])
rm(easts, depth.contour, depth.cont.int, all.maxes, max.lays, full.mat)
d2shr.we <- c(0 + LakeInfo$ints[1]/LakeInfo$slopes[1], -LakeInfo$ints[2]/LakeInfo$slopes[2] - eastr[2])
ACsmryIL$botdep <- zfromx(x=ACsmryIL$interval, maxz=LakeInfo$BotDepMax, eastr=eastr, ints=LakeInfo$ints, slopes=LakeInfo$slopes)
ACsmryIL$d2bot <- ACsmryIL$botdep - ACsmryIL$layer
ACsmryIL$d2sh <- dfromx(x=ACsmryIL$interval, d2shr.we=d2shr.we, eastr=eastr)
# ACsmryIL <- merge(ACsmryIL, sub.mat, all=TRUE)
# ACsmryIL$nperha[is.na(ACsmryIL$nperha)] <- 0
# summarize acoustic data by interval only
ACsmryI <- aggregate(ACsmryIL[, c("sum.rw", "nperha")], 
ACsmryIL[, c("Event", "ACid", "ACnorth", "interval", "botdep", "d2sh")], sum)
ACsmryI <- ACsmryI[order(ACsmryI$Event, ACsmryI$ACid, ACsmryI$interval), ]
acsumil.out.vars <- c("Event", "ACid", "ACnorth", "interval", "layer", "d2sh", "botdep", "d2bot", "sum.rw", "nperha")
acsumi.out.vars <-  c("Event", "ACid", "ACnorth", "interval",          "d2sh", "botdep",          "sum.rw", "nperha")
list(AcCell=ACsmryIL[, acsumil.out.vars], AcColumn=ACsmryI[, acsumi.out.vars] )
}
# perfect
AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, Seed=927)
library(rpart)
# perfect
AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, Seed=927)
#' Combine Acoustic and Midwater Trawl Survey Data
#'
#' Combine survey data from acoustic transects and midwater trawl tows (created by \code{\link{SampFish}}).  
#' Apply availability to the acoustic data and catchability (availability and selectivity) to the midwater trawl catch.
#'
#' @param SimPop A list with elements \code{LakeInfo}, \code{FishInfo}, \code{FishParam}, \code{FishPop}, typically output from \code{\link{SimFish}}.
#' See \code{\link{SimFish}} for details on the list elements.
#' @param AcMtSurv A list with elements \code{Targets}, \code{AcSummaryCell}, \code{AcSummaryColumn}, \code{MtCatch}, 
#' typically output from \code{\link{SampFish}}.
#' @param SelecParamA data frame with 6 columns in which each row provides the midwater trawl selectivity parameters for
#' a given fish group and mesh panel zone.
#' All columns must be completely filled in (no missing values).
#' Selectivity is assumed to be 100\% for any group-zone combination not represented as a row in the data frame.
#' For 100\% selectivity of small fish, use \code{MtL50Small = -Inf} and any slope.  
#' For 100\% selectivity of large fish, use \code{MtL50Large = Inf} and any slope. 
#' Column names and descriptions:
#' \itemize{
#'   \item \code{G} = character, a one-letter nickname for the group (e.g., fish species and lifestage) used in plotting
#'   \item \code{Zone} = character, mesh panel zone, one of "mouth", "middle", "aft", or "cod"
#'   \item \code{MtL50Small} = numeric, the length (in mm) at which small fish have a 50\% probability of being captured by the trawl
#'   \item \code{MtSlopeSmall} = numeric, the (inverse) slope at which small fish probability of capture increases with length, smaller values are steeper
#'   \item \code{MtL50Large} = numeric, the length (in mm) at which large fish have a 50\% probability of being captured by the trawl
#'   \item \code{MtSlopeLarge} = numeric, the (absolute value of the inverse) slope at which large fish probability of capture decreases with length, smaller values are steeper
#' }
#' @param PanelProps A numeric vector of length 4, size of the different mesh panel zones of the midwater trawl, 
#' mouth (outermost), middle, aft, and cod (inner), default c(0.4, 0.3, 0.2, 0.1).
#' Sizes are expressed as proportions of the distance from the outer edge of the trawl to the trawl center in both the vertical and horizontal directions,
#' and they should add up to 1.  Use \code{\link{ViewZones}} to visualize the mesh panel zones.
#' @param AcExclA numeric vector of length 2, depth of acoustic "dead" zones at the surface and at the bottom (in m), 
#' default of c(0, 0) represents 100\% acoustic availability of fish.
#' @param MtExclA numeric vector of length 2, depth of zones unfishable with the midwater trawl at the surface and at the bottom (in m), 
#' default of c(0, 0) represents 100\% midwater trawl availability of fish.
#' @param SeedAn integer scalar, starting seed for stochasticity incorporated in acoustic and midwater trawl catchability.  
#' Use \code{Seed} to ensure the same individual fish are included in the surveys with each call to \code{CatchComb}.  
#' Otherwise, if set to NULL, the default, a random seed is used, resulting in a different fish selection with each call to \code{CatchComb}.  
#'
#' @returnA data frame with estimated fish density (in number per ha) and biomass (in kg per ha) for each sampling event and group (species, lifestage).
#'
#' @details
#'
#' A classification tree is used to relate the catch composition of the midwater trawl to the location of the trawl in the lake 
#' (e.g., MTReast, ACnorth, MTRd2sh, MTRbdep).  This tree is then used to assign a single midwater trawl catch to each acoustic cell
#' (interval x layer), such that the estimated acoustic densities can be assigned to specific fish groups (species, life stages).  See,
#' for example, Yule et al. (2013).
#'
#' @export
#' @importrpart
#' @seealso \code{\link{SimFish}}, \code{\link{SampFish}}, \code{\link{ViewZones}}, \code{\link{TuneSelec}}.
#' @references 
#' 
#' Yule, DL, JV Adams, DM Warner, TR Hrabik, PM Kocovsky, BC Weidel, LG Rudstam, and PJ Sullivan.  2013.  
#' \href{http://www.nrcresearchpress.com/doi/abs/10.1139/cjfas-2013-0072#.U1KYxPldXTQ}{Evaluating 
#' analytical approaches for estimating pelagic fish biomass using simulated fish communities}. 
#' Canadian Journal of Fisheries and Aquatic Sciences 70:1845-1857.
#' 
#' @examples
#'
#' # parameters for small (a) and large (A) alewife as input to the simulator
#' fishp <- data.frame(
#' G = c("a", "A", "A"), 
#' Z = c(50, 140, 140), ZE = c(0.25, 0.2, 0.2), 
#' LWC1 = 0.000014, LWC2 = 2.8638, LWCE = 0.18, 
#' TSC1 = -64.2, TSC2 = 20.5, TSCE = c(0.02, 0.07, 0.07), 
#' PropN = c(0.55, 0.25, 0.20), 
#' E = c(NA, 900, 2800), EE = c(NA, 4.5, 0.3), 
#' N = NA, NE = NA, 
#' WD = c(5, 15, 15), WDE = c(0.5, 0.7, 0.7), 
#' D2B = NA, D2BE = NA)
#' 
#' # simulate the fish population
#' res <- SimFish(LakeName="Clear Lake", LkWidth=3000, LkLength=2000, BotDepMin=20, BotDepMax=100, 
#' FishParam=fishp, TotNFish=50000)
#'
#' # survey the population
#' surv <- SampFish(SimPop=res, NumEvents=2, AcNum=5, AcInterval=3000, AcLayer=10, AcAngle=7, MtNum=25, MtHt=10, MtWd=10, MtLen=200)
#'
#' selec <- data.frame(
#' G = c("A", "a", "A", "a", "A", "a"), 
#' Zone = c("mouth", "mouth", "middle", "middle", "aft", "aft"), 
#' MtL50Small = c(100, 100, 60, 60, 30, 30), 
#' MtSlopeSmall = c(40, 40, 30, 30, 20, 20), 
#' MtL50Large = c(180, 180, Inf, Inf, Inf, Inf), 
#' MtSlopeLarge = c(20, 20, 100, 100, 100, 100))
#'
#' AcMtEst(SimPop=res, AcMtSurv=surv, Seed=927)
#' AcMtEst(SimPop=res, AcMtSurv=surv, SelecParam=selec, AcExcl=c(5, 10), MtExcl=c(2, 2), Seed=204)
#'
AcMtEst <- function(SimPop, AcMtSurv, PanelProps=c(0.4, 0.3, 0.2, 0.1), SelecParam=NULL, AcExcl=c(0, 0), MtExcl=c(0, 0), Seed=NULL) {
# SimPop=res
# AcMtSurv=surv
# SelecParam=selec
# PanelProps=c(0.4, 0.3, 0.2, 0.1)
# AcExcl=c(5, 10)
# MtExcl=c(0, 0)
# Seed=245
if(!is.null(Seed)) set.seed(Seed)
mtr <- AcMtSurv$MtCatch
srv <- AcMtSurv$SurvParam
ac <- AcMtSurv$Targets
# check validity of the trawl zone proportions that were input
names(PanelProps) <- c("mouth", "middle", "aft", "cod")
panelprops <- rev(PanelProps)
if(round(sum(panelprops), 0.0000001) != 1) stop("cod proportions should sum to 1")
# availability function, = 0 at surface and bottom and = 1 in the middle
dblcut <- function(wdep, surfacecut, d2bot, bottomcut) {
as.numeric(wdep > surfacecut & d2bot > bottomcut)
}
# acoustic availability
ac$keep <- with(ac, dblcut(wdep=f.wdep, surfacecut=AcExcl[1], d2bot=f.d2bot, bottomcut=AcExcl[2]))
# summarize by cell (interval x layer)
acs <- AcSmry(AcTarg=ac[ac$keep==1, ], LakeInfo=SimPop$LakeInfo, SurvParam=AcMtSurv$SurvParam)$AcCell
# midwater trawl availability
if(is.null(SelecParam)) {
SelecParam <- data.frame(
G = character(),
Zone = character(),
MtL50Small = numeric(0),
MtSlopeSmall = numeric(0),
MtL50Large = numeric(0),
MtSlopeLarge = numeric(0))
}
# check validity of zones
suz <- c("mouth", "middle", "aft", "cod")
uz <- unique(SelecParam$Zone)
badzones <- setdiff(uz, suz)
if(length(badzones) > 0) stop('Zones must be one of "mouth", "middle", "aft", or "cod".')
# check for missings
missings <- sum(is.na(SelecParam))
if(missings > 0) stop("SelectParam data frame may not have any missing values.")
# fill in 100% selectivities for group-zones with no parameters
sug <- sort(unique(AcMtSurv$MtCatch$G))
full <- expand.grid(G=sug, Zone=suz)
selec2 <- merge(SelecParam, full, all=TRUE)
sel100 <- is.na(selec2$MtL50Small)
selec2$MtL50Small[sel100] <- -Inf
selec2$MtSlopeSmall[sel100] <- 100
selec2$MtL50Large[sel100] <- Inf
selec2$MtSlopeLarge[sel100] <- 200
# for each fish, determine its maximum vertical or horizontal distance from the center of the trawl
# as a proportion of the trawl dimensions
mtr$maxdist <- with(mtr, pmax(abs(f.wdep - MTRwdep)/srv["MtHt"], abs(f.north - ACnorth)/srv["MtWd"]))
# use this distance to assign each fish to a zone of the trawl
mtr$Zone <- cut(mtr$maxdist, breaks=c(0, cumsum(panelprops)), include.lowest=TRUE, labels=names(panelprops))
mtrsel <- merge(mtr, selec2, all.x=TRUE)
# Think about trawl availability ... when we are cutting off trawls near the surface or the bottom, shouldn't this constraint happen
# during the survey itself, where trawls that encompass those "dead" zones can be eliminated?
mtrsel$p.avail <- with(mtrsel, dblcut(wdep=f.wdep, surfacecut=MtExcl[1], d2bot=f.d2bot, bottomcut=MtExcl[2]))
mtrsel$p.selec <- with(mtrsel, logit2(x=len, x50a=MtL50Small, slopea=MtSlopeSmall, x50b=MtL50Large, slopeb=-MtSlopeLarge))
mtrsel$p.catch <- mtrsel$p.avail*mtrsel$p.selec
# apply catchability (selectivity AND availability) functions to "perfect" MTR catch
mtrsel$keep <- sapply(mtrsel$p.catch, function(p) sample(0:1, size=1, replace=TRUE, prob=c(1-p, p)))
sue <- sort(unique(acs$Event))
results <- expand.grid(G=sug, Event=sue, nperha=NA, kgperha=NA)
for(k in sue) {
# subset the MT data
mtk <- mtrsel[mtrsel$Event==k & mtrsel$keep==1, ]
# only do these calculations if there were "keep" fish in the midwater trawl
# without "keep" fish, no species-specific density and biomass can be estimated
if(dim(mtk)[1] > 0) {
# subset the AC data
ack <- acs[acs$Event==k, ]
# make the variable names in mtk the same as in those in ack for tree prediction
names(mtk)[match(c("MTReast", "MTRd2sh", "MTRbdep", "MTRwdep", "MTRd2bot"), names(mtk))] <- c("interval", "d2sh", "botdep", "layer", "d2bot")
# fit a classification tree to the MTR data for Event k
treek <- rpart(as.factor(G) ~ interval + ACnorth + d2sh + botdep + layer + d2bot, data=mtk, control=list(cp=0.05, minsplit=10, minbucket=5))
# mean density for each species
# suffixes:  e = event, a = ac transect, i = interval, l = layer
# use the fitted tree to predict species composition of each AC interval/layer
pred.props <- predict(treek, newdata=ack)
dens.eail <- ack$nperha*pred.props
dens.eai <- aggregate(dens.eail, ack[, c("ACid", "interval")], sum)
dens.e <- apply(dens.eai[, names(dens.eai) %in% sug], 2, mean)
# mean biomass for each species
# calculate the mean weight of each group at each node of the fitted tree
mwt <- tapply(mtk$wt, list(treek$where, mtk$G), mean)
mwt[is.na(mwt)] <- 0
# proportions corresponding to each node
pred.node <- prednode(treek, newdata=ack)
# mean weigth expanded to full dimensions of ack, by matching node number
mwt.eail <- mwt[match(pred.node, row.names(mwt)), ]
bio.eail <- mwt.eail * dens.eail
bio.eai <- aggregate(bio.eail, ack[, c("ACid", "interval")], sum)
bio.e <- apply(bio.eai[, names(bio.eai) %in% sug], 2, mean)
for(g in seq(sug)) {
sel <- results$Event==k & results$G==sug[g]
results$nperha[sel] <- dens.e[sug[g]]
results$kgperha[sel] <- bio.e[sug[g]]/1000
}
}
}
results$nperha[is.na(results$nperha)] <- 0
results$kgperha[is.na(results$kgperha)] <- 0
results[, c("Event", "G", "nperha", "kgperha")]
}
# perfect
AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, Seed=927)
# selectivity
AcMtEst(SimPop=Mfish, AcMtSurv=Msurv, SelecParam=selec, AcExcl=c(5, 10), MtExcl=c(2, 2), Seed=204)
### update package ###
library(devtools)
setwd("C:/JVA/GitHub/artiFISHal")
document()
q()
