TROUTONT<- "Trout Ontario.csv"
MAXLARVAE<- "Max Larval Estimates Summary 2013.xls"
# file name of axis data (x- and y-axis ranges and tick marks)
AXISRANGES<- "AxisRanges.xls"
# file name of the latest status graphs R program
RPROGRAM<- "Status Report Program 1.4.r"
# do you want to install the latest version of the R package jvamisc?
INSTALL.LATEST<- FALSE
###################################################################################
# The rest of this information will likely stay the same from one year to the next.
# set the level of the historic sea lamprey spawner population for each lake
# Superior, Michigan, Huron, Erie, Ontario
HIST.SPAWN <- c(780, 600, 700, 40, 450)*1000
# C:\JVA\GLFC\People\Siefkes\Status Report Program 1.4.r
# This program is called by another script, "Status Report Inputs.r"
options(scipen=4, stringsAsFactors=F)
# install necessary packages
if(INSTALL.LATEST) {
if(!("devtools" %in% installed.packages())) install.packages(devtools, repos="http://cran.r-project.org")
library(devtools)
devtools::install_github("JVAdams/jvamisc")
}
library(jvamisc)
getpackages(c("XLConnect", "rtf", "maps", "plotrix", "zoo", "plyr", "devtools", "plotrix"))
{# Functions and vectors that will be used later
# color-blind friendly colors
col.spa <- 6 # blue
col.day <- 2 # orange
col.tar <- 1 # black
col.tfm <- 5 # yellow
col.bayer <- 8 # reddish purple
col.trt <- 3 # sky blue
col.wou <- 4 # bluish green
# aspect ratios for lake maps, height/width
ASPEX <- c(5/7, 7/5, 8/7, 4/7, 4/7)
TODAY <- format(Sys.time(), "%d-%b-%Y")
suln <- c(Lakenames, "All")
bubbles <- function(long, lat, group, var, thick, thicknamz, lab.dia=0.4, lab.space=0.1, legat="topright", leginset=c(0, 0), 
dr=range(var), cr=c(0.04, 0.5), cols=blindcolz[c(2, 6, 4)], ox=-44, oy=64, mymap=mapp) {
sug <- sort(unique(group))
xr <- range(mymap$x, na.rm=T)
yr <- range(mymap$y, na.rm=T)
xrw <- diff(xr)
yrw <- diff(yr)
bufx <- xrw/40
bufy <- yrw/40
map(xlim=xr + c(-1, 3)*bufx, ylim=yr + c(-1, 1)*bufy, col=NA, mar=c(0, 0.5, 0, 0.5))
pusr <- par("usr")
lines(mymap$x, mymap$y, col="darkgray")
par(xpd=NA)
for(i in seq(sug)) {
sel <- group==sug[i]
selb <- thick & group==sug[i]
circles(long[sel], lat[sel], var[sel], data.range=dr, circle.size.range=cr, outx=ox, outy=oy, add=T, fg=cols[i], lwd=2)
if(sum(selb)>0) {
text(long[selb], lat[selb]-lab.dia*var[selb]/dr[2]-lab.space, thicknamz[selb], srt=0, col=cols[i], cex=1, font=2)
circles(long[selb], lat[selb], var[selb], data.range=dr, circle.size.range=cr, outx=ox, outy=oy,add=T, fg=cols[i], lwd=4)
}
}
}
top50pct <- function(dfvar, xvar, byvar) {
# identify streams with the highest estimates (xvars) combining for more than half the lake (byvar) total
ord <- order(-dfvar[, xvar])
dfsplit <- split(dfvar[ord, ], dfvar[ord, byvar])
dfsplitbig <- lapply(dfsplit, function(df) {
percent <- 100*df[, xvar]/sum(df[, xvar])
cumpercent <- cumsum(percent)
selbig <- (1:dim(df)[1]) <= (sum(cumpercent<50)+1)
df[selbig, ]
})
do.call(rbind, dfsplitbig)
}
status.trend <- function(bydat, timedat, measdat.m, measdat.l=rep(NA, length(measdat.m)), measdat.h=rep(NA, length(measdat.m)), other=NULL,
trend.length=5, response.stat=c("Below", "At", "Above"), response.trend=c("Decreasing", "Steady", "Increasing"),
bytar=sort(unique(bydat)), targdat.m, targdat.l=rep(NA, length(targdat.m)), targdat.h=rep(NA, length(targdat.m))) {
# bydat is a grouping variable
# timedat is a time variable
# measdat._ is the metric of interest .m = estimate, .l=lower CI, .h=upper CI
# other is an additional column of data
# bydat, timedat, measdat._, and other are all the same length
# trend.length is the length of time (number of time units) to examine for trend
# response._ are the responses for current status (.stat) and trend (.trend) 
# bytar is a grouping variable
# targdat._ is the target for the metric of interest .m = target, .l=lower CI, .h=upper CI
# bytar and targdat._ are the same length
# error checking
if(var(c(length(bydat), length(timedat), length(measdat.m), length(measdat.l), length(measdat.h))) > 0) 
stop("bydat, timedat, and measdat._ must all be the same length")
if(!is.null(other) & var(c(length(bydat), length(other))) > 0) 
stop("bydat and other must be the same length")
if(var(c(length(bytar), length(targdat.m), length(targdat.l), length(targdat.h))) > 0) 
stop("bytar and targdat._ must be the same length")
if(!is.null(trend.length) & (trend.length < 2.5 | abs(as.integer(trend.length)-trend.length)>0.0000001)) 
stop("trend.length must be an integer > 2")
if(length(response.stat) != 3 | length(response.trend) != 3) 
stop("response.stat and response.trend must be of length 3")
# set up data
if(!is.null(other)) {
meas <- data.frame(cbind(bydat, timedat, measdat.m, measdat.l, measdat.h, other))
} else {
meas <- data.frame(cbind(bydat, timedat, measdat.m, measdat.l, measdat.h))
}
targ <- data.frame(cbind(bydat=bytar, targdat.m, targdat.l, targdat.h))
# information from latest year of data available - for status assessment
maxtime <- aggregate(timedat ~ bydat, dat=meas[!is.na(measdat.m), ], max)
now <- merge(maxtime, meas)
now <- merge(now, targ)
# set the status to "Above" first
now$stat <- rep(response.stat[3], dim(now)[1])
# meas1 <- ifelse(is.na(now$measdat.h), now$measdat.m, now$measdat.h)
# targ1 <- ifelse(is.na(now$targdat.l), now$targdat.m, now$targdat.l)
now$stat[now$measdat.m < now$targdat.m] <- response.stat[1]
# meas2 <- ifelse(is.na(now$measdat.l), now$measdat.m, now$measdat.l)
# targ2 <- ifelse(is.na(now$targdat.h), now$targdat.m, now$targdat.h)
# now$stat[meas2 > targ2] <- response.stat[3]
if(!is.null(trend.length)) {
sub <- sort(unique(bydat))
trnd <- data.frame(bydat=rep(sub, rep(trend.length, length(sub))), 
timedat=unlist(lapply(maxtime$timedat[1:trend.length], seq, by=-1, length=trend.length)))
now$span <- tapply(trnd$timedat, trnd$bydat, function(x) paste(range(x), collapse="-"))
trnd <- merge(trnd, meas)
coefs <- vector("list", length(sub))
for(i in seq(sub)) coefs[[i]] <- summary(lm(measdat.m ~ timedat, trnd[trnd$bydat==i, ]))$coef
now$slope <- sapply(coefs, "[", 2, 1)
now$pv <- sapply(coefs, "[", 2, 4)
now$trnd <- rep(response.trend[2], length(sub))
now$trnd[now$pv < 0.05 & now$slope < 0] <- response.trend[1]
now$trnd[now$pv < 0.05 & now$slope > 0] <- response.trend[3]
now
}
}
}
oldsci <- options("scipen")
options(scipen=10)
docname <- paste0("Status Report Rough Draft ", TODAY, ".doc")
doc <- startrtf(file=docname, dir=FOLDER)
heading(paste("= = = = = = =   Status Report Tables and Figures -", TODAY, "  = = = = = = ="))
para("This is an automatically generated document named ", docname, 
" stored in the directory ", FOLDER, ".",
" It was created from the following input files: ",
SPAWNER.LAKE, ", ", SPAWNER.STREAM, ", ", CONTROL, ", ", TROUTSUP, ", ", TROUTMIC, ", ", 
TROUTHUR, ", ", TROUTERI, ", ", TROUTONT, ", and ", AXISRANGES,
" using the R program ", RPROGRAM, " authored by Jean V. Adams.")
para("To use the information, first select everything in the document (Ctrl-a)",
" and change the text to the desired font and font size.", 
" Second, save the file as a Word document with the extension *.doc or *.docx,",
" because even though it looks like a Word document initially,",
" it's really just an rtf (rich text format) file.",
" Finally, insert descriptive text as needed, or cut and paste into the primary document.")
{# read in data
# bring in the range data for the x-axis and all the y-axes
wb <- loadWorkbook(paste0(FOLDER, AXISRANGES))
sheet1 <- getSheets(wb)[1]
axisr <- readWorksheet(wb, sheet=sheet1, startRow=2)
# store the tick mark info in an array of lists
um <- unique(axisr$metric)
axisra <- array(list(NULL), dim=c(length(um), 5, 2), dimnames=list(um, 1:5, c("Indiv", "BigFig")))
for(i in seq(um)) {
for(j in 1:5) {
sel <- axisr$metric==um[i] & axisr$order.1==j
axisra[[i, j, 1]] <- seq(axisr$from[sel], axisr$to.[sel], axisr$by[sel])
axisra[[i, j, 2]] <- seq(axisr$from.1[sel], axisr$to..1[sel], axisr$by.1[sel])
}}
rm(axisr, um)
# Lakewide spawner estimates
spawner <- read.csv(paste0(FOLDER, SPAWNER.LAKE))
names(spawner) <- casefold(names(spawner))
names(spawner)[names(spawner)=="year"] <- "spawner.year"
names(spawner)[names(spawner)=="pe"] <- "spawner"
names(spawner)[names(spawner)=="lo"] <- "spawn.lo"
names(spawner)[names(spawner)=="hi"] <- "spawn.hi"
rm(SPAWNER.LAKE, wb, sheet1)
# Lakewide treatment effort
control1 <- read.csv(paste0(FOLDER, CONTROL), skip=1)
names(control1) <- casefold(names(control1))
# ref <- rep(c("All", "Sup", "Mic", "Hur", "StM", "Eri", "Ont", "Tot"), c(1, 3, 3, 3, 2, 3, 3, 3))
days <- unlist(control1[, grep("day", names(control1))])
tfm <- unlist(control1[, grep("tfm", names(control1))])
bayer <- unlist(control1[, grep("bayer", names(control1))])
nobs <- length(control1$year)
reps <- length(days)/nobs
year <- rep(control1$year, reps)
lake <- rep(1:6, rep(nobs, 6))
control <- data.frame(treat.year=year, lake=lake, staff.days=days, tfmkgai=tfm, bayerkgai=bayer)
control <- control[control$lake < 5.5, ]
control$spawner.year <- control$treat.year + 2
# total up the lakes data
sums <- aggregate(control[, 3:5], control[, c(1, 6)], sum)
sums$lake <- 99
control <- rbind(control, sums[, names(control)])
rm(CONTROL, control1, days, tfm, bayer, nobs, reps, year, lake, sums)
# Lakewide lake trout relative abundance estimates and wounding rates
troutfiles <- c(TROUTSUP, TROUTMIC, TROUTHUR, TROUTERI, TROUTONT)
trouts <- vector("list", 5)
# if trout data is missing a desired column, create a column of missing values for it
selcols <- c("year", "lake", "cpe", "lo", "hi", "wound", "wlo", "whi")
for(i in seq(troutfiles)) {
df <- read.csv(paste0(FOLDER, troutfiles[i]))
df$lake <- i
need.names <- setdiff(selcols, names(df))
if(length(need.names) > 0) {
df[, need.names] <- NA
}
trouts[[i]] <- df[, selcols]
}
trout <- do.call(rbind, trouts)
names(trout) <- c("trout.year", "lake", "trout", "trout.lo", "trout.hi", "rate", "rate.lo", "rate.hi")
# Only Superior and Huron trout are assessed in spring
trout$spawner.year <- ifelse((trout$lake==1 | trout$lake==3), trout$trout.year, trout$trout.year+1)
trout$wound.unit <- ifelse(trout$lake==5, '# A1 marks per 100 LAT >17"', '# A1-A3 marks per 100 LAT >21"')
rm(troutfiles, trouts, selcols, TROUTSUP, TROUTMIC, TROUTHUR, TROUTERI, TROUTONT)
}
{# Targets
sptargyrz <- list(1994:1998, 1988:1992, 1989:1993, 1991:1995, 1999:2003)
TARGET <- data.frame(lake=1:5, wound.target=rep(c(5, 2), c(4, 1)), wound.units=rep(c("A1-A3", "A1"), c(4, 1)), 
spawner.target=rep(NA, 5), sptarg.lo=rep(NA, 5), sptarg.hi=rep(NA, 5))
for(i in 1:5) {
pick5 <- spawner$spawner[spawner$lake==i & is.element(spawner$spawner.year, sptargyrz[[i]])]
TARGET$spawner.target[i] <- mean(pick5)
n <- length(pick5)
ci <- qnorm(1 - 0.05/2) * sqrt(var(pick5)) / sqrt(n)
#TARGET[i, 5:6] <- CI(pick5)# using t dist (estimated variance)
TARGET[i, 5:6] <- mean(pick5) + c(-1, 1)*ci# using z dist (known variance)
if(i==3) TARGET[i, 4:6] <- 0.25*TARGET[i, 4:6]
}
TARGET[6, 4:6] <- apply(TARGET[, 4:6], 2, sum)
TARGET[6, 1] <- 99
TARGET[6, 2] <- 5
TARGET[6, 3] <- "A1-A3"
targyrz <- apply(sapply(sptargyrz, range), 2, paste, collapse="-")
rm(pick5, sptargyrz)
name.targ <- paste("Status Targets ", TODAY, ".csv", sep="")
write.csv(TARGET, paste0(FOLDER, name.targ), row.names=F)
}
{# bubble plot data - spawner estimates and maximum larval estimates on  map
# adult data
stream <- read.csv(paste0(FOLDER, SPAWNER.STREAM))
stream$row <- 1:dim(stream)[1]
YEAR <- max(stream$year)
dfthis <- stream[stream$year == YEAR, ]
dfthis <- dfthis[order(dfthis$lake, -dfthis$combPE), ]
# prepare to plot spawner estimates on  map, showing source of estimate ... label those with highest estimates
max.dia.lat <- c(0.42, 0.39, 0.28, 0.28, 0.23)
space.below.lat <- c(0.15, 0.19, 0.16, 0.09, 0.07)
# streams that make up top 50% of adults in current year
selcols <- c("row", "lake", "country", "strname", "lasttrt", "trapcatch", "Emr", "CVmr", "est.source", "combPE")
top50adultsthisyear <- top50pct(dfvar=dfthis[, selcols], xvar="combPE", byvar="lake")
top50adultsthisyear$textpaste <- paste(top50adultsthisyear$strname, format(signif(top50adultsthisyear$combPE, 2), big.mark=",", trim=TRUE))
# max larval data
wb <- loadWorkbook(paste0(FOLDER, MAXLARVAE))
sheet1 <- getSheets(wb)[1]
maxlarvae <- readWorksheet(wb, sheet=sheet1)
names(maxlarvae) <- make.names(casefold(names(maxlarvae)), unique=TRUE, allow_=FALSE)
maxlarvae$row <- 1:dim(maxlarvae)[1]
# drop "river" or "creek" from stream name
namesplit <- strsplit(maxlarvae$stream.nam, " ")
nameend <- sapply(namesplit, function(x) rev(x)[1])
suffixes <- c("Brook", "Cr.", "Creek", "R.", "River", "Rivers")
maxlarvae$stream.nam <- sapply(namesplit, function(x) {
keep <- if(rev(x)[1] %in% suffixes) rev(x)[-1] else rev(x)
paste(rev(keep), collapse=" ")
})
# streams that make up top 50% of max larvae over many years
top50maxlarvae <- top50pct(dfvar=maxlarvae, xvar="estimate", byvar="lake")
top50maxlarvae$textpaste <- paste(top50maxlarvae$stream.nam, format(signif(top50maxlarvae$estimate, 2), big.mark=",", trim=TRUE))
rm(namesplit, nameend, suffixes)
}
{# All lakewide data combined
a <- merge(spawner, control, all=T)
ALL <- merge(a, trout, all=T)
ALL$treat.year <- ALL$spawner.year - 2
ALL <- ALL[!(is.na(ALL$spawner) & is.na(ALL$staff.days) & is.na(ALL$trout) & is.na(ALL$rate)), ]
# the season for Lake Huron has been confirmed by Ji He 4/13/09
ALL$season[is.element(ALL$lake, c(1, 3))] <- "spring"
ALL$season[is.element(ALL$lake, c(2, 4, 5))] <- "fall"
sel <- is.na(ALL$trout.year)
ALL$trout.year[sel] <- ifelse(ALL$season[sel]=="spring", ALL$spawner.year[sel], ALL$spawner.year[sel]-1)
# calculate five-year running mean for adults, marks, and trout
ALL <- ALL[order(ALL$lake, ALL$spawner.year), ]
varz <- c("spawner", "trout", "rate")
look <- ddply(.data=ALL[, c("lake", varz)], .variables=.(lake), .drop=FALSE, .fun=rollapply, width=5, FUN=CI, fill=NA, align="center")
names(look)[-(1:4)] <- paste(rep(varz, rep(3, length(varz))), rep(c("5mn", "5lo", "5hi"), length(varz)), sep=".")
ALL <- cbind(ALL, look[, -(1:4)])
name.dat <- paste("Status Metrics ", TODAY, ".csv", sep="")
write.csv(ALL, paste0(FOLDER, name.dat), row.names=F)
rm(spawner, control, a, trout, varz, look, wb, sheet1)
}
attach(ALL)
# status and trends
addPageBreak(this=doc, width=8.5, height=11, omi=c(1, 1, 1, 1))
heading("SEA LAMPREY STATUS IN THE GREAT LAKES")
# spawner status and 5-year trend
sp <- status.trend(bydat=lake[lake<6], timedat=spawner.year[lake<6], 
measdat.m=spawner[lake<6], measdat.l=spawn.lo[lake<6], measdat.h=spawn.hi[lake<6],
trend.length=5, response.stat=c("Below", "At", "Above *"), response.trend=c("Decreasing", "Steady", "Increasing *"),
bytar=1:5, targdat.m=TARGET$spawner.target[1:5], targdat.l=TARGET$sptarg.lo[1:5], targdat.h=TARGET$sptarg.hi[1:5])
# wounding status and 5-year trend
wo <- status.trend(bydat=lake[lake<6], timedat=trout.year[lake<6], 
measdat.m=rate[lake<6], measdat.l=rate.lo[lake<6], measdat.h=rate.hi[lake<6], other=spawner.year[lake<6], 
trend.length=5, response.stat=c("Below", "At", "Above *"), response.trend=c("Decreasing", "Steady", "Increasing *"),
bytar=1:5, targdat.m=TARGET$wound.target[1:5])
# trout 5-year trend
tr <- status.trend(bydat=lake[lake<6], timedat=trout.year[lake<6], 
measdat.m=trout[lake<6], measdat.l=trout.lo[lake<6], measdat.h=trout.hi[lake<6], other=spawner.year[lake<6], 
trend.length=5, response.stat=c("", "", ""), response.trend=c("Decreasing *", "Steady", "Increasing"),
bytar=1:5, targdat.m=rep(0, 5))
tab <- cbind(sp[, c("bydat", "stat", "trnd")],
wo[, c("timedat", "stat", "span", "trnd")],
tr[, c("span", "trnd")])
tab$bydat <- Lakenames[tab$bydat]
names(tab) <- c("Lake", 
"Adult\nStatus", "\nTrend",
"Marking\nYear", "\nStatus", "\nSpan", "\nTrend",
"Trout\nSpan", "\nTrend")
tabl("Status and trends of lake-wide status metrics: adult sea lamprey abundance, marking rates on lake trout,",
" and lake trout relative abundance.",
" Comparisons to targets are based on the most recent year of data available, ", sp$timedat[1],
", for adult abundance and as noted for marking rates in each lake.",
" Trends are based on the most recent 5 years of data available, ", sp$span[1], 
" for adult abundance and as noted for marking rates and lake trout in each lake.",
" Statuses and trends of concern are noted by an asterisk.", row.names=FALSE)
# REPORT CARD
# merge metrics data with targets
ALL2 <- merge(ALL, TARGET[, c("lake", "wound.target", "spawner.target")], all.x=TRUE)
# Average of spawner numbers relative to target and wounding rates relative to target
# 1 means 1*target (both metrics at or below target), 2 means 2*target (average of both metrics are double the target), etc.
ALL2$above.score <- 0.5 * (ALL2$spawner/ALL2$spawner.target + ALL2$rate/ALL2$wound.target)
# base line width and type on status average for last 5 years
last5 <- (YEAR - ALL2$spawner.year) < 4.5 & ALL2$lake < 6
mean5 <- tapply(ALL2$above.score[last5], ALL2$lake[last5], mean, na.rm=TRUE)
lwid <- round(rescale(mean5, c(1, 5)))
ltyp <- recode(lwid, 5:1, c(1, 5, 4, 2, 3))
last1 <- ALL2$spawner.year == YEAR & ALL2$lake < 6
picklake <- which.max(ALL2$above.score[last1])
selpick <- ALL2$spawner.year == YEAR & ALL2$lake == picklake
picksp <- (ALL2$spawner/ALL2$spawner.target)[selpick]
pickwr <- (ALL2$rate/ALL2$wound.target)[selpick]
picksa <- ALL2$above.score[selpick]
fig <- function() {
par(mar=c(4, 4, 0.5, 5))
plot(ALL2$spawner.year, ALL2$above.score, type="n", xlim=range(ALL2$spawner.year[!is.na(ALL2$above.score)]), las=1, 
xlab="Spawning year", ylab="Status average, relative to target")
pusr <- par("usr")
polygon(pusr[c(1, 2, 2, 1)], c(pusr[c(3, 3)], 1, 1), col="lightgray", border=NA)
box()
for(i in 1:5) {
sel <- ALL2$lake==i
lines(ALL2$spawner.year[sel], ALL2$above.score[sel], col=blindcolz[c(2, 3, 4, 6, 8)[i]], lwd=lwid[i], lty=ltyp[i], lend="square")
mtext(Lakenames[i], at=ALL2$above.score[sel & ALL2$spawner.year==YEAR], col=blindcolz[c(2, 3, 4, 6, 8)[i]], side=4, las=2, line=0.5)
}
}
figu("Status average, relative to target, for each of the Great Lakes.",
"  The status average is the mean of the adult sea lamprey abundance (relative to target) and",
" the lake trout marking rate (relative to target).",
"  For example, for Lake ", Lakenames[picklake], " in spawning year ", YEAR, ", the adult sea lamprey abundance was ", round(picksp, 1), 
" times the target, the wounding rate was ", round(pickwr, 1), " times the target, and the status average was ", round(picksa, 1), ".",
h=3.29, w=3.96)
fig <- function() {
xr <- range(ALL2$spawner.year[!is.na(ALL2$spawner) | !is.na(ALL2$rate)])
par(mfrow=c(1, 2), mar=c(2, 2, 2, 4), oma=c(1, 1, 0, 0))
plot(ALL2$spawner.year, ALL2$spawner/ALL2$spawner.target, type="n", las=1, xlim=xr, ylim=range((ALL2$spawner/ALL2$spawner.target)[last5 & !is.na(ALL2$spawner)]),
xlab="", ylab="")
mtext("Adult sea lamprey abundance", side=3, line=0.5)
pusr <- par("usr")
polygon(pusr[c(1, 2, 2, 1)], c(pusr[c(3, 3)], 1, 1), col="lightgray", border=NA)
box()
for(i in 1:5) {
sel <- ALL2$lake==i
lines(ALL2$spawner.year[sel], (ALL2$spawner/ALL2$spawner.target)[sel], col=blindcolz[c(2, 3, 4, 6, 8)[i]], lwd=lwid[i], lty=ltyp[i], lend="square")
mtext(Lakenames[i], at=(ALL2$spawner/ALL2$spawner.target)[sel & ALL2$spawner.year==YEAR], col=blindcolz[c(2, 3, 4, 6, 8)[i]], side=4, las=2, line=0.5)
}
plot(ALL2$spawner.year, ALL2$rate/ALL2$wound.target, type="n", las=1, xlim=xr, ylim=range((ALL2$rate/ALL2$wound.target)[last5 & !is.na(ALL2$rate)]),
xlab="", ylab="")
mtext("Lake trout marking rate", side=3, line=0.5)
pusr <- par("usr")
polygon(pusr[c(1, 2, 2, 1)], c(pusr[c(3, 3)], 1, 1), col="lightgray", border=NA)
box()
for(i in 1:5) {
sel <- ALL2$lake==i
maxyr <- max(ALL2$spawner.year[sel & !is.na(ALL2$rate)])
lines(ALL2$spawner.year[sel], (ALL2$rate/ALL2$wound.target)[sel], col=blindcolz[c(2, 3, 4, 6, 8)[i]], lwd=lwid[i], lty=ltyp[i], lend="square")
mtext(Lakenames[i], at=(ALL2$rate/ALL2$wound.target)[sel & ALL2$spawner.year==maxyr], col=blindcolz[c(2, 3, 4, 6, 8)[i]], side=4, las=2, line=0.5)
}
mtext("Spawning year", side=1, outer=TRUE)
mtext("Relative to target", side=2, outer=TRUE)
}
figu("Status metrics, relative to target, for each of the Great Lakes.",
"  For example, for Lake ", Lakenames[picklake], " in spawning year ", YEAR, ", the adult sea lamprey abundance was ", round(picksp, 1), 
" times the target, and the wounding rate was ", round(pickwr, 1), " times the target.",
h=3.29, w=6.5)
fig <- function() {
xr <- range(ALL2$spawner.year[(YEAR - ALL2$spawner.year) < 4.5 & (!is.na(ALL2$spawner) | !is.na(ALL2$rate))])
par(mfrow=c(1, 2), mar=c(2, 2, 2, 4), oma=c(1, 1, 0, 0))
plot(ALL2$spawner.year, ALL2$spawner/ALL2$spawner.target, type="n", las=1, xlim=xr, ylim=range((ALL2$spawner/ALL2$spawner.target)[last5 & !is.na(ALL2$spawner)]),
xlab="", ylab="")
mtext("Adult sea lamprey abundance", side=3, line=0.5)
pusr <- par("usr")
polygon(pusr[c(1, 2, 2, 1)], c(pusr[c(3, 3)], 1, 1), col="lightgray", border=NA)
box()
for(i in 1:5) {
sel <- ALL2$lake==i
lines(ALL2$spawner.year[sel], (ALL2$spawner/ALL2$spawner.target)[sel], col=blindcolz[c(2, 3, 4, 6, 8)[i]], lwd=lwid[i], lty=ltyp[i], lend="square")
mtext(Lakenames[i], at=(ALL2$spawner/ALL2$spawner.target)[sel & ALL2$spawner.year==YEAR], col=blindcolz[c(2, 3, 4, 6, 8)[i]], side=4, las=2, line=0.5)
}
plot(ALL2$spawner.year, ALL2$rate/ALL2$wound.target, type="n", las=1, xlim=xr, ylim=range((ALL2$rate/ALL2$wound.target)[last5 & !is.na(ALL2$rate)]),
xlab="", ylab="")
mtext("Lake trout marking rate", side=3, line=0.5)
pusr <- par("usr")
polygon(pusr[c(1, 2, 2, 1)], c(pusr[c(3, 3)], 1, 1), col="lightgray", border=NA)
box()
for(i in 1:5) {
sel <- ALL2$lake==i
maxyr <- max(ALL2$spawner.year[sel & !is.na(ALL2$rate)])
lines(ALL2$spawner.year[sel], (ALL2$rate/ALL2$wound.target)[sel], col=blindcolz[c(2, 3, 4, 6, 8)[i]], lwd=lwid[i], lty=ltyp[i], lend="square")
mtext(Lakenames[i], at=(ALL2$rate/ALL2$wound.target)[sel & ALL2$spawner.year==maxyr], col=blindcolz[c(2, 3, 4, 6, 8)[i]], side=4, las=2, line=0.5)
}
mtext("Spawning year", side=1, outer=TRUE)
mtext("Relative to target", side=2, outer=TRUE)
}
windows()
fig()
xr
xr <- range(ALL2$spawner.year[(YEAR - ALL2$spawner.year) < 4.5 & (!is.na(ALL2$spawner) | !is.na(ALL2$rate))])
xr
paste(xr, collapse=", ")
paste(xr, collapse="-")
# C:\JVA\GLFC\People\Siefkes\Status Report Inputs.r
# change the text in quotes to match the files on your PC
# folder where all of the data files are stored
# make sure that you use forward slashes, /, in place of the usual back slashes, \
FOLDER <- "C:/JVA/GLFC/People/Siefkes/Status graphs/"
# file names of sea lamprey data
SPAWNER.LAKE<- "LakePEdynamic.csv"
SPAWNER.STREAM<- "StreamPEdynamic.csv"
CONTROL <- "Control Table.csv"
TROUTSUP<- "Trout Superior.csv"
TROUTMIC<- "Trout Michigan.csv"
TROUTHUR<- "Trout Huron.csv"
TROUTERI<- "Trout Erie.csv"
TROUTONT<- "Trout Ontario.csv"
MAXLARVAE<- "Max Larval Estimates Summary 2013.xls"
# file name of axis data (x- and y-axis ranges and tick marks)
AXISRANGES<- "AxisRanges.xls"
# file name of the latest status graphs R program
RPROGRAM<- "Status Report Program 1.4.r"
# do you want to install the latest version of the R package jvamisc?
INSTALL.LATEST<- FALSE
###################################################################################
# The rest of this information will likely stay the same from one year to the next.
# set the level of the historic sea lamprey spawner population for each lake
# Superior, Michigan, Huron, Erie, Ontario
HIST.SPAWN <- c(780, 600, 700, 40, 450)*1000
# run the program
source(paste0(FOLDER, RPROGRAM))
search()
detach()
cleanup()
q()
?vapply
require(stats); require(graphics)
x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
# compute the list mean for each list element
lapply(x, mean)
# median and quartiles for each list element
lapply(x, quantile, probs = 1:3/4)
sapply(x, quantile)
i39 <- sapply(3:9, seq) # list of vectors
sapply(i39, fivenum)
vapply(i39, fivenum,
       c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
mapply(rep, 1:4, 4:1)
mapply(rep, times = 1:4, x = 4:1)
mapply(rep, times = 1:4, MoreArgs = list(x = 42))
mapply(function(x, y) seq_len(x) + y,
       c(a =  1, b = 2, c = 3),  # names from first
       c(A = 10, B = 0, C = -10))
word <- function(C, k) paste(rep.int(C, k), collapse = "")
utils::str(mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE))
mapply(rep, times=1:4, x=42)
seq_len(4)
seq_len(1:4)
seq_len(2)
cleanup90
cleanup()
q()
x <- 1:10
res <- NULL
    if(length(x) < 2) return(1)
   vals <- rep.int(1, length(x))
    r <- chisq.out.test(x)
cleanup()
q()
library(devtools)
library(roxygen2)
# install from local folder
setwd("C:/JVA/GitHub")
install("jvamisc")
library(jvamisc)
?cheat
setwd("C:/JVA/GitHub")
install("artiFISHal")
setwd("C:/JVA/R/Working Directory")
library(artiFISHal)
?SimFIsh
?SimFish
q()
?cheat
library(devtools)
setwd("C:/JVA/GitHub/artiFISHal")
document()
document()
q()
